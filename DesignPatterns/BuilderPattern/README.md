## 建造者模式  
### 简介  
&nbsp;&nbsp;&nbsp;&nbsp;老师为Director角色，学生为Builder角色，Teacher隔离了客户端与具体步骤的依赖在一些项目中，经常需要构建一些比较复杂的对象，并对其多个属性进行赋值的复杂操作，程序员的一些忽略可能导致某个属性未被赋值而引起对象的失效，在这种情况下使用构造者模式，创建一个Director来按部就班地指挥一个对象的创建，可以有效的避免意外的发生。使用创建者模式，用户只需要指定创建的类型就可以得到相应的对象，而具体的建造过程和细节就被Director和Builder隐藏了，这正是依赖倒转的体现：抽象不应该依赖于细节，细节应该依赖于抽象。 
### 建造者模式 VS 工厂模式  
&nbsp;&nbsp;&nbsp;&nbsp;和工厂模式一样，建造者模式也属于创建型模式，它们的目的都是得到一个对象。但是两者的侧重点是不同的，工厂模式的侧重点在于将对象的实例化延迟到子类中，而构建者模式的侧重点则是保持一个对象创造过程的稳定性。二者都是将对象的创建过程与客户端进行隔离，工厂模式专注于创建相同表象的对象，但是希望得到具有多种表象的实例时，应该选择建造者模式。  
&nbsp;&nbsp;&nbsp;&nbsp;比如，面包的烤制只是创建了很多同种类型的面包，使得柜台只需向工厂拿面包而已。化学实验则侧重于得到不同表象也就是实验结果不同的情况。  
&nbsp;&nbsp;&nbsp;&nbsp;建造者的作用是隐藏产品的组装过程，如果需要改变一个产品的内部表示（试剂添加量的多少），只需要再定义一个具体的构建者就可以达到目的了。另外构建者模式也是“多态”性使用的一个非常好的应用。  

### 小结  
&nbsp;&nbsp;&nbsp;&nbsp;建造者模式可以说是对流程的抽象，当创建复杂对象的算法应该独立于该对象的组成部分以及它们的组装方式的情况下，适合使用建造者模式。  
&nbsp;&nbsp;&nbsp;&nbsp;同时，另外一种适用的情况是：当构造过程必须允许被构造的对象有不同的表示时。这种情况更适合来强调对象的差异性，所以在构造步骤（算法）比较少的情况下，可以使用无Director的建造者模式，这样做虽然增加了客户端对具体构建过程的依赖性，但是可以起到降低程序复杂性的作用。在实际项目应用中，应该灵活运用而不是教条式的模版套用。  
&nbsp;&nbsp;&nbsp;&nbsp;建造者模式可以把构造对象的实例的逻辑转移到类外面去，在这个类的外部去定义其构造逻辑。而当有些时候我们希望可以减少一个类的规模，通常这个类包含了大量的方法；另外有一种情况就是我们需要按照某种步骤去构造一个对象，造成这种情况的原因是我们只能按部就班地获取构造方法所需要的参数。  
建造者模式是一步一步地去创建一个复杂的对象，它允许用户只需要指定复杂对象的类型和内容就可以构建他们，用户不需要知道复杂对象内部的具体构建细节。建造者模式属于创建型模式（生成器模式）。  
&nbsp;&nbsp;&nbsp;&nbsp;建造者模式有以下优点：  
>* 在建造者模式中，客户端不必知道产品内部组成的具体细节，将产品本身与产品的创建过程进行解耦，使得相同的创建过程可以创建出不同的产品对象。  
>* 每一个具体的建造者都是相对独立的，而与其他的具体建造者没有关系，因此可以很方便地去替换具体建造者或者增加新的具体建造者，用户可以使用不同的具体建造者得到不同的产品对象。  
>* 可以更加精细地控制产品创建的具体过程。将复杂产品的创建步骤分解在不同的方法当中，使得创建过程更加清晰，也更加方便使用程序对创建过程进行控制。  
>* 增加新的具体建造者不用修改原来类库的代码，指挥者类是针对抽象建造者类编程的，系统拓展方便，符合“开放--封闭”原则。  



